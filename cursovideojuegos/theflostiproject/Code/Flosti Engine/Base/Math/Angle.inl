///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// establece el angulo a partir de un valor en RADIANES
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline void CAngle<T>::SetRad(T value)
{
  m_Value = value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// establece el angulo a partir de un valor en GRADOS
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline void CAngle<T>::SetDeg(T value)
{
  m_Value = mathUtils::Deg2Rad(value);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// devuelve el valor del angulo en radianes
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline T CAngle<T>::GetRad() const 
{ 
  return m_Value; 
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// devuelve el valor del angulo en grados
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline T CAngle<T>::GetDeg() const 
{ 
  return mathUtils::Rad2Deg(m_Value); 
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// convierte el angulo a su representacion canonica (entre [-PI, PI])
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
void CAngle<T>::Canonize()
{ 
  // la forma canonica de x es: x - (max - min) * floor((x + min) / (max-min) 
  //m_Value -= CAngle<T>::PIx2 * mathUtils::Floor(m_Value * CAngle<T>::PIx2_Inv);
  m_Value -= e2PI<T>() * mathUtils::Floor(m_Value * eIn2PI<T>());
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// obtiene la representacion canonica del angulo (entre [-PI, PI])
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline T CAngle<T>::GetCanonical() const
{
  // la forma canonica de x es: x - (max - min) * floor((x + min) / (max-min) 
  return ( m_Value - e2PI<T>() * mathUtils::Floor(m_Value * eIn2PI<T>()) );  
  //return ( m_Value - CAngle<T>::PIx2 * mathUtils::Floor(m_Value * CAngle<T>::PIx2_Inv) );
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// suma de angulos
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline CAngle<T> CAngle<T>::operator+ (const CAngle<T>& other) const
{
  return CAngle<T>(m_Value + other.m_Value);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// suma de angulos
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline CAngle<T>& CAngle<T>::operator+= (const CAngle<T>& other)
{
  m_Value += other.m_Value;
  return (*this);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// suma de angulos a partir de un valor en RADIANES
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline CAngle<T> CAngle<T>::operator+ (T value) const
{
  return CAngle<T>(m_Value + value);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// suma de angulos a partir de un valor en RADIANES
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline CAngle<T>& CAngle<T>::operator+= (T value)
{
  m_Value += value;
  return (*this);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// resta de angulos
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline CAngle<T> CAngle<T>::operator- (const CAngle<T>& other) const
{
  return CAngle<T>(m_Value - other.m_Value);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// resta de angulos  
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline CAngle<T>& CAngle<T>::operator-= (const CAngle<T>& other)
{
  m_Value -= other.m_Value;
  return (*this);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// resta de angulos a partir de un valor en RADIANES
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline CAngle<T> CAngle<T>::operator- (T value) const
{
  return CAngle<T>(m_Value - value);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// resta de angulos a partir de un valor en RADIANES
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline CAngle<T>& CAngle<T>::operator-= (T value)
{
  m_Value -= value;
  return (*this);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// multiplicacion por un escalar
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline CAngle<T> CAngle<T>::operator*(T value) const
{
  return CAngle<T>(m_Value * value);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// multiplicacion por un escalar
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline CAngle<T>& CAngle<T>::operator*= (T value)
{
  m_Value *= value;
  return (*this);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// division por un escalar
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline CAngle<T> CAngle<T>::operator / (T value) const
{
#ifdef CHECK_MATH_SINGULARITY 
//---------------------------------------------------------
  // Con chequeo de división por cero
  ASSERTMSG(value != Zero<T>(), "División por cero en cociente ángulo-escalar");
  if (value != Zero<T>())
    return CAngle<T>(m_Value / value);
  else
    return CAngle<T>();
//---------------------------------------------------------
#else  
//---------------------------------------------------------
  // Sin chequeo
  return CAngle<T>(m_Value / value);
//---------------------------------------------------------
#endif 
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// division por un escalar
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline CAngle<T>& CAngle<T>::operator/= (T value)
{
#ifdef CHECK_MATH_SINGULARITY 
  //---------------------------------------------------------
  // Con chequeo de división por cero
  ASSERTMSG(value != Zero<T>(), "Tratando de dividir por cero");
  if (value != Zero<T>())
    m_Value /= value;
  //---------------------------------------------------------
#else  
  //---------------------------------------------------------
  // Sin chequeo
  m_Value /= value;
  //---------------------------------------------------------
#endif 
  
  return (*this);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Comparacion de angulos. Internamente se compara la representacion canonica y se tiene en cuenta un epsilon para 
/// evitar problemas de precision de decimales.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline bool CAngle<T>::operator== (const CAngle<T>& other) const
{
  return mathUtils::ZeroEpsilon(GetCanonicalDistance(other).GetRad());
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Comparacion de angulos. Internamente se compara la representacion canonica y se tiene en cuenta un epsilon para 
/// evitar problemas de precision de decimales.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline bool CAngle<T>::operator!= (const CAngle<T>& other) const
{
  return !mathUtils::ZeroEpsilon(GetCanonicalDistance(other).GetRad());
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Método de comparación de ángulos al que se le puede pasar el Epsilon de margen de comparación 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline bool CAngle<T>::IsEqualEpsilon (const CAngle<T>& other, const T Epsilon) const
{
  return mathUtils::ZeroEpsilon(GetCanonicalDistance(other).GetRad(), Epsilon);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Método de comparación de ángulos al que se le puede pasar el Epsilon de margen de comparación 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
inline bool CAngle<T>::IsNotEqualEpsilon (const CAngle<T>& other, const T Epsilon) const
{
  return !mathUtils::ZeroEpsilon(GetCanonicalDistance(other).GetRad(), Epsilon);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// operador suma binario con un valor en RADIANES
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T> 
inline CAngle<T> operator+ (const T value, const CAngle<T>& other)
{
  return CAngle<T>(value + other.GetRad());
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// operador resta binario con un valor en RADIANES
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T> 
inline CAngle<T> operator- (const T value, const CAngle<T>& other)
{
  return CAngle<T>(value - other.GetRad());
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// distancia entre angulos
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T> 
CAngle<T> CAngle<T>::GetDistance(const CAngle<T>& other) const
{
  T dist = other.GetRad() - m_Value;

  return CAngle<T>(dist);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// distancia entre angulos. Devuelve el angulo mas corto entre las representaciones canonicas de ambos angulos, es
/// decir, primero obtiene las representaciones canonicas de los angulos y despues calcula la distancia mas corta
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T> 
CAngle<T> CAngle<T>::GetCanonicalDistance(const CAngle<T>& other) const
{
  T dist = other.GetCanonical() - GetCanonical();

  /*if (dist > CAngle<T>::PI)
    dist -= CAngle<T>::PIx2;
  else if (dist < -CAngle<T>::PI)
    dist += CAngle<T>::PIx2;*/

  if (dist > ePI<T>())
    dist -= e2PI<T>();
  else if (dist < -ePI<T>())
    dist += e2PI<T>();

  return CAngle<T>(dist);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// interpolacion lineal
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T> 
inline CAngle<T> CAngle<T>::GetLerp (const CAngle<T>& other, const T t) const
{
  return CAngle<T>(m_Value + (other.GetRad() - m_Value) * t);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// interpolacion lineal. Devuelve la interpolacion entre las representaciones canonicas de ambos angulos, es
/// decir, primero obtiene las representaciones canonicas de los angulos y despues calcula la interpolacion. @Note1
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T> 
inline CAngle<T> CAngle<T>::GetCanonicalLerp (const CAngle<T>& other, const T t) const
{
  T canonical = GetCanonical();
  T dist = other.GetCanonical() - canonical;

  /*if (dist > CAngle<T>::PI)
    dist -= CAngle<T>::PIx2;
  else if (dist < -CAngle<T>::PI)
    dist += CAngle<T>::PIx2;*/

  if (dist > ePI<T>())
    dist -= e2PI<T>();
  else if (dist < -ePI<T>())
    dist += e2PI<T>();

  return CAngle<T>(canonical + dist * t);
}


